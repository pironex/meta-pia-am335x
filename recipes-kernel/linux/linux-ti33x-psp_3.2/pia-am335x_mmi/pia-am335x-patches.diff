diff --git a/arch/arm/mach-omap2/board-am335xpia.c b/arch/arm/mach-omap2/board-am335xpia.c
index 7360a13..3f1f613 100644
--- a/arch/arm/mach-omap2/board-am335xpia.c
+++ b/arch/arm/mach-omap2/board-am335xpia.c
@@ -16,15 +16,336 @@
 #include <linux/init.h>
 #include <linux/i2c.h>
 #include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/i2c/at24.h>
+#include <linux/mfd/tps65910.h>
+
+#include <mach/hardware.h>
 
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+
+#include <plat/omap_device.h>
+#include <plat/irqs.h>
+#include <plat/board.h>
+#include <plat/common.h>
+#include <plat/mmc.h>
 
 #include "common.h"
+#include "cpuidle33xx.h"
+#include "mux.h"
+#include "hsmmc.h"
+
+/* Convert GPIO signal to GPIO pin number */
+#define GPIO_TO_PIN(bank, gpio) (32 * (bank) + (gpio))
+
+/* module pin mux structure */
+struct pinmux_config {
+	const char *string_name; /* signal name format */
+	int val; /* Options for the mux register value */
+};
+
+/*
+* @pin_mux - single module pin-mux structure which defines pin-mux
+*			details for all its pins.
+*/
+static void setup_pin_mux(struct pinmux_config *pin_mux)
+{
+	int i;
+
+	for (i = 0; pin_mux->string_name != NULL; pin_mux++)
+		omap_mux_init_signal(pin_mux->string_name, pin_mux->val);
+
+}
+
+#ifdef CONFIG_OMAP_MUX
+static struct omap_board_mux board_mux[] __initdata = {
+	AM33XX_MUX(I2C0_SDA, OMAP_MUX_MODE0 | AM33XX_SLEWCTRL_SLOW |
+			AM33XX_INPUT_EN | AM33XX_PIN_OUTPUT),
+	AM33XX_MUX(I2C0_SCL, OMAP_MUX_MODE0 | AM33XX_SLEWCTRL_SLOW |
+			AM33XX_INPUT_EN | AM33XX_PIN_OUTPUT),
+	{ .reg_offset = OMAP_MUX_TERMINATOR },
+};
+#else
+#define	board_mux	NULL
+#endif
+
+/*
+* EVM Config held in On-Board eeprom device.
+*
+* Header Format
+*
+*  Name			Size	Contents
+*			(Bytes)
+*-------------------------------------------------------------
+*  Header		4	0xAA, 0x55, 0x33, 0xEE
+*
+*  Board Name		8	Name for board in ASCII.
+*				example "A33515BB" = "AM335X
+				Low Cost EVM board"
+*
+*  Version		4	Hardware version code for board in
+*				in ASCII. "1.0A" = rev.01.0A
+*
+*  Serial Number	12	Serial number of the board. This is a 12
+*				character string which is WWYY4P16nnnn, where
+*				WW = 2 digit week of the year of production
+*				YY = 2 digit year of production
+*				nnnn = incrementing board number
+*
+*  Configuration option	32	Codes(TBD) to show the configuration
+*				setup on this board.
+*
+*  Available		32720	Available space for other non-volatile
+*				data.
+*/
+struct pia335x_eeprom_config {
+	u32	header;
+	u8	name[8];
+	char	version[4];
+	u8	serial[12];
+	u8	opt[32];
+};
+static struct pia335x_eeprom_config config;
+
+/* Module pin mux for mmc0 */
+static struct pinmux_config mmc0_pin_mux[] = {
+	{"mmc0_dat3.mmc0_dat3",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_dat2.mmc0_dat2",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_dat1.mmc0_dat1",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_dat0.mmc0_dat0",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_clk.mmc0_clk",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_cmd.mmc0_cmd",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mii1_txclk.gpio3_9", AM33XX_PIN_INPUT_PULLUP},
+	{"mii1_txd2.gpio0_17",  OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
+	{NULL, 0},
+};
+
+static struct omap2_hsmmc_info pia335x_mmc[] __initdata = {
+	{
+		.mmc            = 1,
+		.caps           = MMC_CAP_4_BIT_DATA,
+		.gpio_cd        = GPIO_TO_PIN(0, 17),
+		.gpio_wp        = GPIO_TO_PIN(3, 9),
+		.ocr_mask       = MMC_VDD_32_33 | MMC_VDD_33_34, /* 3V3 */
+	},
+	{
+		.mmc            = 0,	/* will be set at runtime */
+	},
+	{
+		.mmc            = 0,	/* will be set at runtime */
+	},
+	{}      /* Terminator */
+};
+
+static void mmc0_init(void)
+{
+	setup_pin_mux(mmc0_pin_mux);
+
+	omap2_hsmmc_init(pia335x_mmc);
+	return;
+}
+
+static void pia335x_setup(struct memory_accessor *mem_acc, void *context)
+{
+	int ret;
+	/* get board specific data */
+	ret = mem_acc->read(mem_acc, (char *)&config, 0, sizeof(config));
+	/* FIXME */
+}
+
+/**
+ * I2C devices
+ */
+#define PIA335X_EEPROM_I2C_ADDR 0x50
+static struct at24_platform_data pia335x_eeprom_info = {
+	.byte_len       = 128,
+	.page_size      = 8,
+	.flags          = AT24_FLAG_TAKE8ADDR,
+	.setup          = pia335x_setup,
+	.context        = (void *)NULL,
+};
+
+static struct regulator_init_data pia335x_tps_dummy = {
+	.constraints.always_on	= true,
+};
+
+static struct tps65910_board pia335x_tps65910_info = {
+	.tps65910_pmic_init_data[TPS65910_REG_VRTC]	= &pia335x_tps_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VIO]	= &pia335x_tps_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VDD1]	= &pia335x_tps_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VDD2]	= &pia335x_tps_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VDD3]	= &pia335x_tps_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VDIG1]	= &pia335x_tps_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VDIG2]	= &pia335x_tps_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VPLL]	= &pia335x_tps_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VDAC]	= &pia335x_tps_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VAUX1]	= &pia335x_tps_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VAUX2]	= &pia335x_tps_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VAUX33]	= &pia335x_tps_dummy,
+	.tps65910_pmic_init_data[TPS65910_REG_VMMC]	= &pia335x_tps_dummy,
+};
+
+
+static struct i2c_board_info __initdata pia335x_i2c1_boardinfo[] = {
+	{
+		/* Daughter Board EEPROM */
+		I2C_BOARD_INFO("24c00", PIA335X_EEPROM_I2C_ADDR),
+		.platform_data  = &pia335x_eeprom_info,
+	},
+	{
+		I2C_BOARD_INFO("tps65910", TPS65910_I2C_ID1),
+		.platform_data  = &pia335x_tps65910_info,
+	},
+};
+
+static void __init pia335x_i2c_init(void)
+{
+	/* Initially assume Low Cost EVM Config */
+	//am335x_evm_id = LOW_COST_EVM;
+
+	omap_register_i2c_bus(1, 100, pia335x_i2c1_boardinfo,
+				ARRAY_SIZE(pia335x_i2c1_boardinfo));
+}
+
+/**
+ * AM33xx internal RTC
+ */
+static struct resource pia335x_rtc_resources[] = {
+	{
+		.start		= AM33XX_RTC_BASE,
+		.end		= AM33XX_RTC_BASE + SZ_4K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	{ /* timer irq */
+		.start		= AM33XX_IRQ_RTC_TIMER,
+		.end		= AM33XX_IRQ_RTC_TIMER,
+		.flags		= IORESOURCE_IRQ,
+	},
+	{ /* alarm irq */
+		.start		= AM33XX_IRQ_RTC_ALARM,
+		.end		= AM33XX_IRQ_RTC_ALARM,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
 
+static struct platform_device pia335x_rtc_device = {
+	.name           = "omap_rtc",
+	.id             = -1,
+	.num_resources	= ARRAY_SIZE(pia335x_rtc_resources),
+	.resource	= pia335x_rtc_resources,
+};
+
+static int pia335x_rtc_init(void)
+{
+	void __iomem *base;
+	struct clk *clk;
+
+	clk = clk_get(NULL, "rtc_fck");
+	if (IS_ERR(clk)) {
+		pr_err("rtc : Failed to get RTC clock\n");
+		return -1;
+	}
+
+	if (clk_enable(clk)) {
+		pr_err("rtc: Clock Enable Failed\n");
+		return -1;
+	}
+
+	base = ioremap(AM33XX_RTC_BASE, SZ_4K);
+
+	if (WARN_ON(!base))
+		return -ENOMEM;
+
+	/* Unlock the rtc's registers */
+	writel(0x83e70b13, base + 0x6c);
+	writel(0x95a4f1e0, base + 0x70);
+
+	/*
+	 * Enable the 32K OSc
+	 * TODO: Need a better way to handle this
+	 * Since we want the clock to be running before mmc init
+	 * we need to do it before the rtc probe happens
+	 */
+	writel(0x48, base + 0x54);
+
+	iounmap(base);
+
+	return  platform_device_register(&pia335x_rtc_device);
+}
+
+void __iomem *pia335x_emif_base;
+
+void __iomem * __init pia335x_get_mem_ctlr(void)
+{
+
+	pia335x_emif_base = ioremap(AM33XX_EMIF0_BASE, SZ_32K);
+
+	if (!pia335x_emif_base)
+		pr_warning("%s: Unable to map DDR2 controller",	__func__);
+
+	return pia335x_emif_base;
+}
+
+#ifndef CONFIG_MACH_AM335XEVM
+void __iomem *am33xx_get_ram_base(void)
+{
+	return pia335x_emif_base;
+}
+#endif
+
+static struct resource am33xx_cpuidle_resources[] = {
+	{
+		.start		= AM33XX_EMIF0_BASE,
+		.end		= AM33XX_EMIF0_BASE + SZ_32K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+};
+
+/* AM33XX devices support DDR2 power down */
+static struct am33xx_cpuidle_config pia335x_cpuidle_pdata = {
+	.ddr2_pdown	= 1,
+};
+
+static struct platform_device pia335x_cpuidle_device = {
+	.name			= "cpuidle-am33xx",
+	.num_resources		= ARRAY_SIZE(am33xx_cpuidle_resources),
+	.resource		= am33xx_cpuidle_resources,
+	.dev = {
+		.platform_data	= &pia335x_cpuidle_pdata,
+	},
+};
+
+static void __init pia335x_cpuidle_init(void)
+{
+	int ret;
+
+	pia335x_cpuidle_pdata.emif_base = pia335x_get_mem_ctlr();
+
+	ret = platform_device_register(&pia335x_cpuidle_device);
+
+	if (ret)
+		pr_warning("AM33XX cpuidle registration failed\n");
+
+}
+
+#include <mach/board-am335xevm.h>
 static void __init pia335x_init(void)
 {
-	// TODO implement
+	pia335x_cpuidle_init();
+	am33xx_mux_init(board_mux);
+	omap_serial_init();
+	pia335x_rtc_init();
+	pia335x_i2c_init();
+
+	mmc0_init();
+
+	am33xx_evmid_fillup(PIA335_KM_E2);
+	am33xx_cpsw_init(0);
 }
 
 static void __init pia335x_map_io(void)
diff --git a/arch/arm/mach-omap2/devices.c b/arch/arm/mach-omap2/devices.c
index 3ef045e..c22b502 100644
--- a/arch/arm/mach-omap2/devices.c
+++ b/arch/arm/mach-omap2/devices.c
@@ -1382,6 +1382,10 @@ void am33xx_cpsw_init(unsigned int gigen)
 	} else if (am33xx_evmid == IND_AUT_MTR_EVM) {
 		am33xx_cpsw_slaves[0].phy_id = "0:1e";
 		am33xx_cpsw_slaves[1].phy_id = "0:00";
+	} else if (am33xx_evmid == PIA335_KM_E2) {
+		printk("PIA E2: init CPSW PHY IDs\n");
+		//FIXME am33xx_cpsw_slaves[0].phy_id = "0:1e";
+		//am33xx_cpsw_slaves[1].phy_id = "0:00";
 	} else {
 		__raw_writel(RGMII_MODE_ENABLE,
 				AM33XX_CTRL_REGADDR(MAC_MII_SEL));
diff --git a/arch/arm/mach-omap2/include/mach/board-am335xevm.h b/arch/arm/mach-omap2/include/mach/board-am335xevm.h
index a8fe93a..9473401 100644
--- a/arch/arm/mach-omap2/include/mach/board-am335xevm.h
+++ b/arch/arm/mach-omap2/include/mach/board-am335xevm.h
@@ -26,6 +26,7 @@
 #define IP_PHN_EVM		3
 #define BEAGLE_BONE_OLD		4
 #define BEAGLE_BONE_A3		5
+#define PIA335_KM_E2		20
 
 /* REVIST : check posibility of PROFILE_(x) syntax usage */
 #define PROFILE_NONE	-1	/* Few EVM doesn't have profiles */
